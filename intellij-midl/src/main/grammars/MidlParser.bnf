{
//  generate=[psi="no"]
//  generatePsi=false // We employ hand-written Kotlin PSI
  parserClass="net.demurgos.midl.lang.parser.MidlParser"
//  parserUtilClass="org.toml.lang.parse.TomlParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Midl"
  psiImplClassSuffix="Impl"
  psiPackage="net.demurgos.midl.lang.psi"
  psiImplPackage="net.demurgos.midl.lang.psi.impl"

  elementTypeHolderClass="net.demurgos.midl.lang.psi.MidlTypes"
  elementTypeClass="net.demurgos.midl.lang.psi.MidlElementType"
  tokenTypeClass="net.demurgos.midl.lang.psi.MidlTokenType"

  tokens = [
    LCURLY
    RCURLY
    LBRACK
    RBRACK
    LPAREN
    RPAREN
    COLON
    SEMICOLON
    EQ

    COMMENT

    BOOL_LITERAL
    INT_LITERAL
    STRING_LITERAL

    TYPE_KW
    IDENTIFIER
    WHITE_SPACE
  ]
}

File ::= Item*

Item ::= TypeAssignment | Attribute | COMMENT | WHITE_SPACE

TypeAssignment ::= TYPE_KW WHITE_SPACE IDENTIFIER WHITE_SPACE? EQ WHITE_SPACE? Expr

//// to keep this sample short function calls and other expressions are omitted
//{
//  extends(".*expr")=expr
//}
// the root expression rule
Expr ::= EqExprGroup
  | OrExpr
  | AndExpr
  | NotExpr
  | PrimaryExprGroup

// private rules to define operators with the same priority
private EqExprGroup ::= EqExpr | NotEqExpr
private PrimaryExprGroup ::= StructExpr | LiteralExpr | ParenExpr

//EqExpr ::= Expr EQEQ Expr { rightAssociative=true }
EqExpr ::= Expr WHITE_SPACE? EQEQ WHITE_SPACE? Expr {extends=Expr}
NotEqExpr ::= Expr WHITE_SPACE? EXCLEQ WHITE_SPACE? Expr {extends=Expr}
OrExpr ::= Expr (WHITE_SPACE? OR WHITE_SPACE? Expr)+ {extends=Expr}
AndExpr ::= Expr (WHITE_SPACE? AND WHITE_SPACE? Expr)+ {extends=Expr}
NotExpr ::= EXCL WHITE_SPACE? Expr {extends=Expr}
ParenExpr ::= LPAREN WHITE_SPACE? Expr WHITE_SPACE? RPAREN {extends=Expr}
LiteralExpr ::= BOOL_LITERAL | INT_LITERAL | STRING_LITERAL {extends=Expr}

StructExpr ::= STRUCT_KW WHITE_SPACE? LCURLY WHITE_SPACE? (StructItem WHITE_SPACE?)* RCURLY {extends=Expr}
StructItem ::= IDENTIFIER WHITE_SPACE? COLON WHITE_SPACE? Expr WHITE_SPACE? SEMICOLON
Attribute ::= LBRACK IDENTIFIER RBRACK
